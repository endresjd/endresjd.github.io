<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>John Endres</title><description>Trying to illustrate the obtuseness.</description><link>https://johnendres.com</link><language>en</language><lastBuildDate>Tue, 11 May 2021 16:24:00 -0400</lastBuildDate><pubDate>Tue, 11 May 2021 16:24:00 -0400</pubDate><ttl>250</ttl><atom:link href="https://johnendres.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://johnendres.com/publish/spashcrap</guid><title>How the #$%^&amp; do you get the hilighting to work</title><description>Splash crap.</description><link>https://johnendres.com/publish/spashcrap</link><pubDate>Tue, 11 May 2021 16:06:17 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Tuesday, May 11, 2021 at 4:06 PM</p><h1>How the #$%^&amp; do you get the hilighting to work</h1><p>Wasting time trying to get Swift code to format properly from the markdown files. Just all stupidity on my part.</p><p>&nbsp;</p><h2>What needs to be done</h2><ol><li>You have to add SplashPublishPlugin as a package dependency</li><li>You have to define the proper CSS (not mentioned)</li><li>You have to install the publishing step BEFORE the markdown parser, which makes sense in retrospect</li><li>And, worse of all, it's a plugin for Spash. Go to the right freaking documentation to figure out how things work.</li></ol><p>&nbsp;</p><p>&nbsp;</p><p>Finally a blank line! <code>&amp;nbsp;</code></p><p>&nbsp;</p><h2>Here's some samples</h2><p>Using a nice looking color scheme from one of the sample sites.</p><p>&nbsp;</p><pre><code><span class="keyword">try</span> <span class="type">DeliciousRecipes</span>().<span class="call">publish</span>(using: [
    ...
    .<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"johnsundell/delicious-recipes"</span>))
])
</code></pre><pre><code><span class="keyword">struct</span> Theme {
    <span class="keyword">static let</span> primary = <span class="type">UIColor</span>(red: <span class="number">255</span>/<span class="number">255</span>, green: <span class="number">82</span>/<span class="number">255</span>, blue: <span class="number">82</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
    <span class="keyword">static let</span> primaryLight = <span class="type">Theme</span>.<span class="property">primary</span>.<span class="call">withAlphaComponent</span>(<span class="number">0.9</span>)
    <span class="keyword">static let</span> backgroundColor = <span class="type">UIColor</span>(red: <span class="number">239</span>/<span class="number">255</span>, green: <span class="number">239</span>/<span class="number">255</span>, blue: <span class="number">244</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/publish/publishing</guid><title>Seeing about publishing pipelines</title><description>Publishing Step Understanding.</description><link>https://johnendres.com/publish/publishing</link><pubDate>Tue, 11 May 2021 15:23:53 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Tuesday, May 11, 2021 at 3:23 PM</p><h1>Seeing about publishing pipelines</h1><p>Publishing is a series of steps that transform the content of the website from files and swift into what goes into the Output folder. After running the full sequence of steps successfully, a fully generated website should be placed in the Output folder.</p><h2>Types of publishing tasks</h2><ol><li>adding, removing, mutating content (various types) such as items, pages, markdownFiles, etc.</li><li>copying things into the website. Resources, files,</li><li>generating content: generateHTML, generateRSSFeed, generateSiteMap</li><li>podcast information: generatePodcastFeed</li><li>deploy (using a given method)</li></ol><h2>What is the deploy step?</h2><p>Publish can also facilitate the deployment of websites to external servers through its DeploymentMethod API, and ships with built-in implementations for Git and GitHub-based deployments. To define a deployment method for a website, add the deploy step to your publishing pipeline:</p><h3>From the documentation</h3><pre><code><span class="keyword">try</span> <span class="type">DeliciousRecipes</span>().<span class="call">publish</span>(using: [
    ...
    .<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"johnsundell/delicious-recipes"</span>))
])
</code></pre><p>Implies that it is deploying the website to GitHub. The top level seems to have raw git commands for pushing folder contents to a repository. What it is pushing is some kind of deployment directory that it creates.</p><ul><li>Publish can also facilitate the deployment of websites to external servers through its DeploymentMethod API, and ships with built-in implementations for Git and GitHub-based deployments. To define a deployment method for a website, add the deploy step to your publishing pipeline:</li><li>Even when added to a pipeline, deployment steps are disabled by default, and are only executed when the --deploy command line flag was passed (which can be added through Xcode’s Product &gt; Scheme &gt; Edit Scheme... menu), or by running the command line tool using publish deploy.</li><li>Creates a hidden folder: .publish/GitDeploy/ at the project level.</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/posts/README</guid><title>README</title><description>Sundell's README.</description><link>https://johnendres.com/posts/README</link><pubDate>Tue, 11 May 2021 15:09:59 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Tuesday, May 11, 2021 at 3:09 PM</p><p align="center">
    <img src="https://johnendres.com/images/Logo.png" width="400" max-width="90%" alt="Publish" />
</p><p align="center">
    <img src="https://img.shields.io/badge/Swift-5.4-orange.svg" />
    <a href="https://swift.org/package-manager">
        <img src="https://img.shields.io/badge/swiftpm-compatible-brightgreen.svg?style=flat" alt="Swift Package Manager" />
    </a>
     <img src="https://img.shields.io/badge/platforms-mac+linux-brightgreen.svg?style=flat" alt="Mac + Linux" />
    <a href="https://twitter.com/johnsundell">
        <img src="https://img.shields.io/badge/twitter-@johnsundell-blue.svg?style=flat" alt="Twitter: @johnsundell" />
    </a>
</p><p>Welcome to <strong>Publish</strong>, a static site generator built specifically for Swift developers. It enables entire websites to be built using Swift, and supports themes, plugins and tons of other powerful customization options.</p><p>Publish is used to build all of <a href="https://swiftbysundell.com">swiftbysundell.com</a>.</p><h2>Websites as Swift packages</h2><p>When using Publish, each website is defined as a Swift package, which acts as the configuration as to how the website should be generated and deployed — all using native, type-safe Swift code. For example, here’s what the configuration for a food recipe website might look like:</p><pre><code><span class="keyword">struct</span> DeliciousRecipes: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> recipes
        <span class="keyword">case</span> links
        <span class="keyword">case</span> about
    }

    <span class="keyword">struct</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span> {
        <span class="keyword">var</span> ingredients: [<span class="type">String</span>]
        <span class="keyword">var</span> preparationTime: <span class="type">TimeInterval</span>
    }

    <span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="string">"https://cooking-with-john.com"</span>)!
    <span class="keyword">var</span> name = <span class="string">"Delicious Recipes"</span>
    <span class="keyword">var</span> description = <span class="string">"Many very delicious recipes."</span>
    <span class="keyword">var</span> language: <span class="type">Language</span> { .<span class="dotAccess">english</span> }
    <span class="keyword">var</span> imagePath: <span class="type">Path</span>? { <span class="string">"images/logo.png"</span> }
}
</code></pre><p>Each website built using Publish can freely decide what kind of sections and metadata that it wants to support. Above, we’ve added three sections — <em>Recipes</em>, <em>Links</em>, and <em>About</em> — which can then contain any number of items. We’ve also added support for our own, site-specific item metadata through the <code>ItemMetadata</code> type, which we’ll be able to use in a fully type-safe manner all throughout our publishing process.</p><h2>Start out simple, and customize when needed</h2><p>While Publish offers a really powerful API that enables almost every aspect of the website generation process to be customized and tweaked, it also ships with a suite of convenience APIs that aims to make it as quick and easy as possible to get started.</p><p>To start generating the <em>Delicious Recipes</em> website we defined above, all we need is a single line of code, that tells Publish which theme to use to generate our website’s HTML:</p><pre><code><span class="keyword">try</span> <span class="type">DeliciousRecipes</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p><em>Not only does the above call render our website’s HTML, it also generates an RSS feed, a site map, and more.</em></p><p>Above we’re using Publish’s built-in Foundation theme, which is a very basic theme mostly provided as a starting point, and as an example of how Publish themes may be built. We can of course at any time replace that theme with our own, custom one, which can include any sort of HTML and resources that we’d like.</p><p>By default, Publish will generate a website’s content based on Markdown files placed within that project’s <code>Content</code> folder, but any number of content items and custom pages can also be added programmatically.</p><p><strong>Publish supports three types of content:</strong></p><p><strong>Sections</strong>, which are created based on the members of each website’s <code>SectionID</code> enum. Each section both has its own HTML page, and can also act as a container for a list of <strong>Items</strong>, which represent the nested HTML pages within that section. Finally, <strong>Pages</strong> provide a way to build custom free-form pages that can be placed into any kind of folder hierarchy.</p><p>Each <code>Section</code>, <code>Item</code>, and <code>Page</code> can define its own set of Content — which can range from text (like titles and descriptions), to HTML, audio, video and various kinds of metadata.</p><p>Here’s how we could extend our basic <code>publish()</code> call from before to inject our own custom publishing pipeline — which enables us to define new items, modify sections, and much more:</p><pre><code><span class="keyword">try</span> <span class="type">DeliciousRecipes</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">foundation</span>,
    additionalSteps: [
        <span class="comment">// Add an item programmatically</span>
        .<span class="call">addItem</span>(<span class="type">Item</span>(
            path: <span class="string">"my-favorite-recipe"</span>,
            sectionID: .<span class="dotAccess">recipes</span>,
            metadata: <span class="type">DeliciousRecipes</span>.<span class="type">ItemMetadata</span>(
                ingredients: [<span class="string">"Chocolate"</span>, <span class="string">"Coffee"</span>, <span class="string">"Flour"</span>],
                preparationTime: <span class="number">10</span> * <span class="number">60</span>
            ),
            tags: [<span class="string">"favorite"</span>, <span class="string">"featured"</span>],
            content: <span class="type">Content</span>(
                title: <span class="string">"Check out my favorite recipe!"</span>
            )
        )),
        <span class="comment">// Add default titles to all sections</span>
        .<span class="call">step</span>(named: <span class="string">"Default section titles"</span>) { context <span class="keyword">in</span>
            context.<span class="call">mutateAllSections</span> { section <span class="keyword">in
                guard</span> section.<span class="property">title</span>.<span class="property">isEmpty</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
                
                <span class="keyword">switch</span> section.<span class="property">id</span> {
                <span class="keyword">case</span> .<span class="dotAccess">recipes</span>:
                    section.<span class="property">title</span> = <span class="string">"My recipes"</span>
                <span class="keyword">case</span> .<span class="dotAccess">links</span>:
                    section.<span class="property">title</span> = <span class="string">"External links"</span>
                <span class="keyword">case</span> .<span class="dotAccess">about</span>:
                    section.<span class="property">title</span> = <span class="string">"About this site"</span>
                }
            }
        }
    ]
)
</code></pre><p>Of course, defining all of a program’s code in one single place is rarely a good idea, so it’s recommended to split up a website’s various generation operations into clearly separated steps — which can be defined by extending the <code>PublishingStep</code> type with static properties or methods, like this:</p><pre><code><span class="keyword">extension</span> <span class="type">PublishingStep</span> <span class="keyword">where</span> <span class="type">Site</span> == <span class="type">DeliciousRecipes</span> {
    <span class="keyword">static func</span> addDefaultSectionTitles() -&gt; <span class="type">Self</span> {
        .<span class="call">step</span>(named: <span class="string">"Default section titles"</span>) { context <span class="keyword">in</span>
            context.<span class="call">mutateAllSections</span> { section <span class="keyword">in
                guard</span> section.<span class="property">title</span>.<span class="property">isEmpty</span> <span class="keyword">else</span> { <span class="keyword">return</span> }

                <span class="keyword">switch</span> section.<span class="property">id</span> {
                <span class="keyword">case</span> .<span class="dotAccess">recipes</span>:
                    section.<span class="property">title</span> = <span class="string">"My recipes"</span>
                <span class="keyword">case</span> .<span class="dotAccess">links</span>:
                    section.<span class="property">title</span> = <span class="string">"External links"</span>
                <span class="keyword">case</span> .<span class="dotAccess">about</span>:
                    section.<span class="property">title</span> = <span class="string">"About this site"</span>
                }
            }
        }
    }
}
</code></pre><p><em>Each publishing step is passed an instance of <code>PublishingContext</code>, which it can use to mutate the current context in which the website is being published — including its files, folders, and content.</em></p><p>Using the above pattern, we can implement any number of custom publishing steps that’ll fit right in alongside all of the default steps that Publish ships with. This enables us to construct really powerful pipelines in which each step performs a single part of the generation process:</p><pre><code><span class="keyword">try</span> <span class="type">DeliciousRecipes</span>().<span class="call">publish</span>(using: [
    .<span class="call">addMarkdownFiles</span>(),
    .<span class="call">copyResources</span>(),
    .<span class="call">addFavoriteItems</span>(),
    .<span class="call">addDefaultSectionTitles</span>(),
    .<span class="call">generateHTML</span>(withTheme: .<span class="dotAccess">delicious</span>),
    .<span class="call">generateRSSFeed</span>(including: [.<span class="dotAccess">recipes</span>]),
    .<span class="call">generateSiteMap</span>()
])
</code></pre><p><em>Above we’re constructing a completely custom publishing pipeline by calling the <code>publish(using:)</code> API.</em></p><p>To learn more about Publish’s built-in publishing steps, <a href="https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/PublishingStep.swift">check out this file</a>.</p><h2>Building an HTML theme</h2><p>Publish uses <a href="https://github.com/johnsundell/plot">Plot</a> as its HTML theming engine, which enables entire HTML pages to be defined using Swift. When using Publish, it’s recommended that you build your own website-specific theme — that can make full use of your own custom metadata, and be completely tailored to fit your website’s design.</p><p>Themes are defined using the <code>Theme</code> type, which uses an <code>HTMLFactory</code> implementation to create all of a website’s HTML pages. Here’s an excerpt of what the implementation for the custom <code>.delicious</code> theme used above may look like:</p><pre><code><span class="keyword">extension</span> <span class="type">Theme</span> <span class="keyword">where</span> <span class="type">Site</span> == <span class="type">DeliciousRecipes</span> {
    <span class="keyword">static var</span> delicious: <span class="type">Self</span> {
        <span class="type">Theme</span>(htmlFactory: <span class="type">DeliciousHTMLFactory</span>())
    }

    <span class="keyword">private struct</span> DeliciousHTMLFactory: <span class="type">HTMLFactory</span> {
        ...
        <span class="keyword">func</span> makeItemHTML(
            for item: <span class="type">Item</span>&lt;<span class="type">DeliciousRecipes</span>&gt;,
            context: <span class="type">PublishingContext</span>&lt;<span class="type">DeliciousRecipes</span>&gt;
        ) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
            <span class="type">HTML</span>(
                .<span class="call">head</span>(for: item, on: context.<span class="property">site</span>),
                .<span class="call">body</span>(
                    .<span class="call">ul</span>(
                        .<span class="call">class</span>(<span class="string">"ingredients"</span>),
                        .<span class="call">forEach</span>(item.<span class="property">metadata</span>.<span class="property">ingredients</span>) {
                            .<span class="call">li</span>(.<span class="call">text</span>($0))
                        }
                    ),
                    .<span class="call">p</span>(
                        <span class="string">"This will take around "</span>,
                        <span class="string">"</span>\(<span class="type">Int</span>(item.<span class="property">metadata</span>.<span class="property">preparationTime</span> / <span class="number">60</span>)) <span class="string">"</span>,
                        <span class="string">"minutes to prepare"</span>
                    ),
                    .<span class="call">contentBody</span>(item.<span class="property">body</span>)
                )
            )
        }
        ...
    }
}
</code></pre><p>Above we’re able to access both built-in item properties, and the custom metadata properties that we defined earlier as part of our website’s <code>ItemMetadata</code> struct, all in a way that retains full type safety.</p><p><em>More thorough documentation on how to build Publish themes, and some of the recommended best practices for doing so, will be added shortly.</em></p><h2>Building plugins</h2><p>Publish also supports plugins, which can be used to share setup code between various projects, or to extend Publish’s built-in functionality in various ways. Just like publishing steps, plugins perform their work by modifying the current <code>PublishingContext</code> — for example by adding files or folders, by mutating the website’s existing content, or by adding Markdown parsing modifiers.</p><p>Here’s an example of a plugin that ensures that all of a website’s items have tags:</p><pre><code><span class="keyword">extension</span> <span class="type">Plugin</span> {
    <span class="keyword">static var</span> ensureAllItemsAreTagged: <span class="type">Self</span> {
        <span class="type">Plugin</span>(name: <span class="string">"Ensure that all items are tagged"</span>) { context <span class="keyword">in
            let</span> allItems = context.<span class="property">sections</span>.<span class="call">flatMap</span> { $0.<span class="property">items</span> }

            <span class="keyword">for</span> item <span class="keyword">in</span> allItems {
                <span class="keyword">guard</span> !item.<span class="property">tags</span>.<span class="property">isEmpty</span> <span class="keyword">else</span> {
                    <span class="keyword">throw</span> <span class="type">PublishingError</span>(
                        path: item.<span class="property">path</span>,
                        infoMessage: <span class="string">"Item has no tags"</span>
                    )
                }
            }
        }
    }
}
</code></pre><p>Plugins are then installed by adding the <code>installPlugin</code> step to any publishing pipeline:</p><pre><code><span class="keyword">try</span> <span class="type">DeliciousRecipes</span>().<span class="call">publish</span>(using: [
    ...
    .<span class="call">installPlugin</span>(.<span class="dotAccess">ensureAllItemsAreTagged</span>)
])
</code></pre><p><em>If your plugin is hosted on GitHub you can use the <code>publish-plugin</code> <a href="https://help.github.com/en/github/administering-a-repository/classifying-your-repository-with-topics#adding-topics-to-your-repository">topic</a> so it can be found with the rest of <a href="https://github.com/topics/publish-plugin?l=swift">community plugins</a>.</em></p><p>For a real-world example of a Publish plugin, check out the <a href="https://github.com/johnsundell/splashpublishplugin">official Splash plugin</a>, which makes it really easy to integrate the <a href="https://github.com/johnsundell/splash">Splash syntax highlighter</a> with Publish.</p><h2>System requirements</h2><p>To be able to successfully use Publish, make sure that your system has Swift version 5.4 (or later) installed. If you’re using a Mac, also make sure that <code>xcode-select</code> is pointed at an Xcode installation that includes the required version of Swift, and that you’re running macOS Big Sur (11.0) or later.</p><p>Please note that Publish <strong>does not</strong> officially support any form of beta software, including beta versions of Xcode and macOS, or unreleased versions of Swift.</p><h2>Installation</h2><p>Publish is distributed using the <a href="https://swift.org/package-manager">Swift Package Manager</a>. To install it into a project, add it as a dependency within your <code>Package.swift</code> manifest:</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    ...
    dependencies: [
        .<span class="call">package</span>(url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.1.0"</span>)
    ],
    ...
)
</code></pre><p>Then import Publish wherever you’d like to use it:</p><pre><code><span class="keyword">import</span> Publish
</code></pre><p>For more information on how to use the Swift Package Manager, check out <a href="https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager">this article</a>, or <a href="https://swift.org/package-manager">its official documentation</a>.</p><p>Publish also ships with a command line tool that makes it easy to set up new website projects, and to generate and deploy existing ones. To install that command line tool, simply run <code>make</code> within a local copy of the Publish repo:</p><pre><code>$ git clone https://github.<span class="property">com</span>/<span class="type">JohnSundell</span>/<span class="type">Publish</span>.<span class="property">git</span>
$ cd <span class="type">Publish</span>
$ make
</code></pre><p>Then run <code>publish help</code> for instructions on how to use it.</p><p>The Publish command line tool is also available via <a href="https://brew.sh">Homebrew</a> and can be installed using the following command if you have Homebrew installed:</p><pre><code>brew install publish
</code></pre><h2>Running and deploying</h2><p>Since all Publish websites are implemented as Swift packages, they can be generated simply by opening up a website’s package in Xcode (by opening its <code>Package.swift</code> file), and then running it using the <code>Product &gt; Run</code> command (or <code>⌘+R</code>).</p><p>Publish can also facilitate the deployment of websites to external servers through its <code>DeploymentMethod</code> API, and ships with built-in implementations for Git and GitHub-based deployments. To define a deployment method for a website, add the <code>deploy</code> step to your publishing pipeline:</p><pre><code><span class="keyword">try</span> <span class="type">DeliciousRecipes</span>().<span class="call">publish</span>(using: [
    ...
    .<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"johnsundell/delicious-recipes"</span>))
])
</code></pre><p>Even when added to a pipeline, deployment steps are disabled by default, and are only executed when the <code>--deploy</code> command line flag was passed (which can be added through Xcode’s <code>Product &gt; Scheme &gt; Edit Scheme...</code> menu), or by running the command line tool using <code>publish deploy</code>.</p><p>Publish can also start a <code>localhost</code> web server for local testing and development, by using the <code>publish run</code> command. To regenerate site content with the server running, use Product &gt; Run on your site's package in Xcode.</p><h2>Quick start</h2><p>To quickly get started with Publish, install the command line tool by first cloning this repository, and then run <code>make</code> within the cloned folder:</p><pre><code>$ git clone https://github.<span class="property">com</span>/<span class="type">JohnSundell</span>/<span class="type">Publish</span>.<span class="property">git</span>
$ cd <span class="type">Publish</span>
$ make
</code></pre><p><strong>*Note</strong>: If you encounter an error while running <code>make</code>, ensure that you have your Command Line Tools location set from Xcode's preferences. It's in Preferences &gt; Locations &gt; Locations &gt; Command Line Tools. The dropdown will be blank if it hasn't been set yet._</p><p>Then, create a new folder for your new website project and simply run <code>publish new</code> within it to get started:</p><pre><code>$ mkdir <span class="type">MyWebsite</span>
$ cd <span class="type">MyWebsite</span>
$ publish new
</code></pre><p>Finally, run <code>open Package.swift</code> to open up the project in Xcode to start building your new website.</p><h2>Additional documentation</h2><p>You can find a growing collection of additional documentation about Publish’s various features and capabilities within the <a href="Documentation">Documentation folder</a>.</p><h2>Design and goals</h2><p>Publish was first and foremost designed to be a powerful and heavily customizable tool for building static websites in Swift — starting with <a href="https://swiftbysundell.com">Swift by Sundell</a>, a website which has over 300 individual pages and a pipeline consisting of over 25 publishing steps.</p><p>While the goal is definitely also to make Publish as accessible and easy to use as possible, it will most likely keep being a quite low-level tool that favors code-level control over file system configuration files, and customizability over strongly held conventions.</p><p>The main trade-off of that design is that Publish will likely have a steeper learning curve than most other static site generators, but hopefully it’ll also offer a much greater degree of power, flexibility and type safety as a result. Over time, and with the community’s help, we should be able to make that learning curve much less steep though — through much more thorough documentation and examples, and through shared tools and convenience APIs.</p><p>Publish was also designed with code reuse in mind, and hopefully a much larger selection of themes, tools, plugins and other extensions will be developed by the community over time.</p><h2>Contributions and support</h2><p>Publish is developed completely in the open, and your contributions are more than welcome.</p><p>Before you start using Publish in any of your projects, it’s highly recommended that you spend a few minutes familiarizing yourself with its documentation and internal implementation, so that you’ll be ready to tackle any issues or edge cases that you might encounter.</p><p>Since this is a very young project, it’s likely to have many limitations and missing features, which is something that can really only be discovered and addressed as more people start using it. While Publish is used in production to build all of <a href="https://swiftbysundell.com">Swift by Sundell</a>, it’s recommended that you first try it out for your specific use case, to make sure it supports the features that you need.</p><p>This project does not come with GitHub Issues-based support, and users are instead encouraged to become active participants in its continued development — by fixing any bugs that they encounter, or by improving the documentation wherever it’s found to be lacking.</p><p>If you wish to make a change, <a href="https://github.com/JohnSundell/Publish/pull/new">open a Pull Request</a> — even if it just contains a draft of the changes you’re planning, or a test that reproduces an issue — and we can discuss it further from there.</p><p>Hope you’ll enjoy using Publish!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/publish/high%20level%20points</guid><title>High-level points</title><description>High-level points</description><link>https://johnendres.com/publish/high%20level%20points</link><pubDate>Tue, 11 May 2021 13:54:57 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Tuesday, May 11, 2021 at 1:54 PM</p><h1>High-level points</h1><ol><li>Creates Swift executable packages that output static web sites based on resources on disk and in code.</li><li>Works in a similar way as SwiftUI where the structure of the web pages is defined by code using functions similar to HTML tags but with a slightly different style</li><li>The basic layout is very close to Sundell's web site. The theming differs.</li><li>Theming inside the app is what really gives each page its layout, style, and content. Replacing the foundation theme with a custom one gives complete control.</li><li>Styling is done by css. The general look can be controlled using the Foundation theme by adjusting styles.css, but then only by duplicating the code and manually getting a replacement css file put into the resources folder. (My current understanding)</li><li>Files with web site content are markdown files, but the display of those is in HTML, so the rendering will be different. It depends on the theme, and that theme's underlying css styling. A good example is with these numbered lists. The alignment is good in markdown but way off in HTML. (This may be more aligned with how the default styling/css is setup to support his site than it does with HTML)</li><li>Default publish steps (for generating the site) are minimal, so you usually will need to enumerate out all the steps. Some, like sorting, can be missed easily and this is why the order of listed posts was unsorted.</li><li>Markdown can have raw HTML in it that can help in things like images.</li></ol><h1>Review of theme Nodes</h1><p>These are the types of pages the theme is called on to create.</p><ol><li>Index: page generated that represents the landing point for the web site. Default lists all the latest cotent.</li><li>Section: a page that displaya summaries for each file in a container, which is a folder in the Content.</li><li>Item: a page that shows the content of one of the markdown files in a container.</li><li>Page: a single page that is not part of a container. Either done in code or a markdown file in the content that is not a container (folder)</li><li>Tag List: HTML to use for the website's list of tags, if supported.</li><li>Tag Details: HTML to use for a tag details page, used to represent a single tag.</li></ol><p>Comment from addMarkdownFiles(): Parse a folder of Markdown files and use them to add content to the website. The root folders will be parsed as sections, and the files within them as items, while root files will be parsed as pages.</p><h1>Some assumptions</h1><ol><li>Maybe I don't have to know how it reads in and parses the files. That's at a low level, and my known exposure to that data is in the theming part with the data already parsed out into the objects I need. Control over display would be through css.</li><li>Indentation isn't something I understand well enough. It's to control if the web page uses tabs or spaces when it indents. Not sure how that might apply to web pages, so I'm leaving it alone.</li></ol><h1>Frameworks</h1><p>The whole package is broken down into subframeworks that are also from Sundell including at least one I've been using in other projects.</p><ol><li>Codextended -- Extensions giving Swift's Codable API type inference super powers</li><li>Files -- A nicer way to handle files &amp; folders in Swift</li><li>Ink -- A fast and flexible Markdown parser written in Swift</li><li>Plot -- A DSL for writing type-safe HTML, XML and RSS in Swift</li><li>Publish -- A static site generator for Swift developers</li><li>Sweep -- Fast and powerful Swift string scanning made simple</li></ol><h1>Observations</h1><ol><li>Ink framework converts Markdown into HTML. See MarkdownParser.parse()</li><li>Seems hard to customize the styling for heading tags.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/posts/nottagged</guid><title>To illustrate the custom plugin</title><description>A file that doesn't have tags.</description><link>https://johnendres.com/posts/nottagged</link><pubDate>Tue, 11 May 2021 13:24:18 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Tuesday, May 11, 2021 at 1:24 PM</p><h1>To illustrate the custom plugin</h1><p>Tag line: tags: publish Removing this will cause the pipeline to fail</p>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/publish/theming</guid><title>Understand HTML Themes</title><description>HTML Themes</description><link>https://johnendres.com/publish/theming</link><pubDate>Fri, 7 May 2021 09:46:53 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Friday, May 7, 2021 at 9:46 AM</p><h1>Understand HTML Themes</h1><p>Going from the snippet on the Sundell site to the more complex one in the example I've been basing my learning off of and capturing some notes.</p><h2>From documentation</h2><p>Publish uses Plot as its HTML theming engine, which enables entire HTML pages to be defined using Swift. When using Publish, it’s recommended that you build your own website-specific theme — that can make full use of your own custom metadata, and be completely tailored to fit your website’s design.</p><p>Themes are defined using the Theme type, which uses an HTMLFactory implementation to create all of a website’s HTML pages.</p><h2>The key item</h2><p>More thorough documentation on how to build Publish themes, and some of the recommended best practices for doing so, will be added shortly.</p><h2>How to use a theme</h2><p>The generateHTML step generates the HTML defined in the Swift files based on the given theme. In this example it is using an extension referenced by the stativ var personal that creates an instance of an HTMLFactory customized locally.</p><p>.generateHTML(withTheme: .personal),</p><p>Generating a new theme seems to require duplicating the foundation theme entirely, since it is private, and moving on from there. Inside that theme are references to style sheets referenced via paths. Seeing how to reference our own. The base css file is tightly bound to the foundation theme, so seems like a good base/match. The problem is that the foundation theme seems to override all attempts at me overriding it. The style is copied, but into a sub folder. If put at the top it will fail because of the foundation one.</p><p>Made a styles folder (similar to the other project) with a modified styles.css, made my theme not copy over anything (the copy phase gets the default one always maybe?), and added a new copy phase to get the updated stylesheet. This allowed me to use the right styles. It still required a hard copy of the original theme code.</p><p><strong>Key</strong>: Resource paths are generated from the package folder and not the Resources folder. When specifying, you have to start with Resources.</p><p><strong>Look at</strong>: Indentation options used in the generate step.</p><h1>Factory protocol</h1><p>Each theme needs to be able to create each of the main 6 parts of a Publish web site.</p><ol><li>makeIndexHTML -- Create the HTML to use for the website's main index page.</li><li>makeSectionHTML -- Create the HTML to use for the index page of a section</li><li>makeItemHTML -- Create the HTML to use for an item</li><li>makePageHTML -- Create the HTML to use for a page</li><li>makeTagListHTML -- Create the HTML to use for the website's list of tags, if supported</li><li>makeTagDetailsHTML -- Create the HTML to use for a tag details page, used to represent a single tag</li></ol><h1>How does markdown translate to HTML</h1><p>Looking at makePageHTML() for this because this is where contentBody() is called. This just renders already premade body.html. Of course the current debugger wont print the value of that to the console.</p><p>The theme object uses a private extension to Node that has helpers for different elements it looks like.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/publish/structure</guid><title>HTML structure</title><description>Looking at HTML layout in themes</description><link>https://johnendres.com/publish/structure</link><pubDate>Thu, 6 May 2021 16:30:17 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Thursday, May 6, 2021 at 4:30 PM</p><h1>HTML structure</h1>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/publish/metadata</guid><title>Looking at metadata in markdown files</title><description>Some metadata in markdown files.</description><link>https://johnendres.com/publish/metadata</link><pubDate>Thu, 6 May 2021 14:05:43 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Thursday, May 6, 2021 at 2:05 PM</p><h1>Looking at metadata in markdown files</h1><h2>Comments</h2><p>Publish.Location has documentation (comments) on some of the format here. I notice that some of these rely on HTML knowledge I really don't have.</p><h2>Title</h2><h3>Metadata</h3><p>title metadata will be used at the outer level to show the title of the article before you click on it.</p><h3>Top-Level H1 heading</h3><p>The top-level H1 heading is used when showing this file. If missing, there will be no title.</p><h3>Conclusion</h3><p>Conclusion is to not use the metadata unless you write a publishing step to reinsert it into this page when rendered.</p><h2>Description</h2><h3>Metadata</h3><p>Entered at the top of the file. A description of the location. When parsing a location from Markdown, a description may be defined using the <code>description</code> metadata key. This is displayed in the list of items page as an overview of what the post is about.</p><h2>Date</h2><h3>Observation</h3><p>The date is used for sorting but doesn't seem to be displayed normally. The sample project displays it on the item being displayed with code to modify the post's output.</p><h3>Metadata</h3><p>If specified, this will be used as the date of the item. A way to manually set the date and time. Funny to note that I used the wrong date here (typo in the year).</p><p>date: 2022-05-06 10:03</p><h3>Normal operation</h3><p>The date for the post is normally the modification date of the file.</p><h3>Conclusion</h3><p>Unless something is screwey with modification dates changing, this would be the better approach rather than trying to keep things current by hand.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/publish/observations</guid><title>Initial information gathering</title><description>Inital investigation of Publish.</description><link>https://johnendres.com/publish/observations</link><pubDate>Thu, 6 May 2021 14:05:41 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Thursday, May 6, 2021 at 2:05 PM</p><h1>Initial information gathering</h1><p>The documentation is very brief and really does not cover much, so this covers top-level topics from the documentation along with observation from trial-and-error runs and from web sites I've found that are based on Publish.</p><h2>Links that helped</h2><ul><li><a href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a href="https://www.mxgzf.com/posts/2020-03-03-Relaunching-my-website-using-Swift/">Relaunching my website using Swift</a></li><li><a href="https://github.com/crelies/christianelies.de">Christian Elies</a></li></ul><h2>Markdown</h2><p>Markdown is wonky. Doesn't render the way I'm expecting. This is where theming and customization probably is needed based on the layout of other pages.</p><h1>HomeBrew tools</h1><p>Working with the websites is done through a tool published with Homebrew called publish. Install that and the commands it provides become clear.</p><h2>publish new</h2><p>Set up a new website in the current folder as a Swift Package Manager project.</p><h2>publish generate</h2><p>Generate the website in the current folder.</p><h2>publish deploy</h2><p>Generate and deploy the website in the current folder, according to its deployment method.</p><h2>publish run</h2><p>Generate and run a localhost server on default port 8000 for the website in the current folder. Use the "-p" or "--port" option for customizing the default port.<br><br>Now it says very clearly, but I didn't notice, but you can regenerate the web site by running the project in Xcode instead of stopping and starting the server all the time.</p><h1>Terms</h1><h2>Website</h2><p>Protocol used to define a Publish-based website. You conform to this protocol using a custom type, which is then used to infer various information about your website when generating its various HTML pages and resources. A website is then published using a pipeline made up of PublishingStep values, which is constructed using the publish method. To generate the necessary bootstrapping for conforming to this protocol, use the publish new command line tool.</p><h2>WebsiteSectionID</h2><p>Used with an associated type to define sections for each site. The enum elements define the sections that are display across the top of the screen for the current theme. The order of the enums is the order they are displayed across the screen.</p><h2>Content</h2><p><strong>Sections</strong>	created based on the members of each website’s SectionID enum. Each section both has its own HTML page, and can also act as a container for a list of Items. <strong>Section.md</strong> renders as a standalone page. <strong>Section/</strong> (a folder) renders the md files inside of it in a list for that section. This container can further customize the section name by defining index.md whose content is a single line with header 1 style. This defines the name that shows at the top of the container.</p><p><strong>Items</strong> which represent the nested HTML pages within that section. As I understand this, in the simplist case, an item is a markdown file inside a section folder.</p><p><strong>Pages</strong> provide a way to build custom free-form pages that can be placed into any kind of folder hierarchy. I believe, but am not certain, that this is done with the help of code.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://johnendres.com/posts/2019-03-20-aerogami_series_part_4</guid><title>Building a real-world iOS app (Part 4): Design</title><description></description><link>https://johnendres.com/posts/2019-03-20-aerogami_series_part_4</link><pubDate>Wed, 20 Mar 2019 12:00:00 -0400</pubDate><content:encoded><![CDATA[<p class="post date">Wednesday, March 20, 2019 at 12:00 PM</p><p>User experience (UX) and design is an integral part of any application. As a developer, I don't have much knowledge or "feeling" towards good looking designs. Moreover, truly great user experience requires many iterations of development and feedback. In this part we'll see how we can take example from Apple's mobile apps and design guidelines to create a familiar looking application.</p><h1>Colors</h1><p>We'll begin to design by choosing the color palette of our application. One of the best ways to ensure familiarity and simplicity of the app is to have consistent colors throughout the application. I found it a great advice to limit yourself to 1 or 2 colors.</p><p>There are a few tools online to generate color palettes so the colors would fit together nicely.</p><p>Chosen colors should be put in a common place so it could be easily accessible.</p><pre><code><span class="keyword">struct</span> Theme {
    <span class="keyword">static let</span> primary = <span class="type">UIColor</span>(red: <span class="number">255</span>/<span class="number">255</span>, green: <span class="number">82</span>/<span class="number">255</span>, blue: <span class="number">82</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
    <span class="keyword">static let</span> primaryLight = <span class="type">Theme</span>.<span class="property">primary</span>.<span class="call">withAlphaComponent</span>(<span class="number">0.9</span>)
    <span class="keyword">static let</span> backgroundColor = <span class="type">UIColor</span>(red: <span class="number">239</span>/<span class="number">255</span>, green: <span class="number">239</span>/<span class="number">255</span>, blue: <span class="number">244</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
}
</code></pre><h1>UI</h1><p>Apple provides great resources for getting started. <a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a> is a great starting point for understanding the thinking behind Apple's choices as well as their preferences. Users have certain expectations and habits when using any application and it's important not to distract them with an unexpected behavior.</p><p>We'll take the inspiration from already existing <em>AppStore</em> app. The main screen of this app has a feed that we want to display in our travel application as well.</p><img src="https://johnendres.com/images/aerogami-tutorial/part4/app_screen_example.png" alt="App Scren Example" width="300"/><p>Apple also provides us with <a href="https://developer.apple.com/design/resources/">design resources</a> that contain <a href="https://www.sketch.com">Sketch</a> files with designs of already existing applications. When learning to sketch or design something, I found it really beneficial to have these in front of me.</p><p>After tweaking these screens and applying our color palette we can create the first version of our design.</p><img src="https://johnendres.com/images/aerogami-tutorial/part4/app_screen_real.png" alt="Feed Screen" width="300"/><p>It displays the essential information such as <em>origin</em>, <em>destination</em>, <em>dates</em> and <em>price</em>. We can also show images which provide visual information about the destination.</p><h1>App Icon</h1><p>Application icon is also a huge part of first impression of any application. We can use same given <a href="https://developer.apple.com/design/resources/">design resources</a> that include examples of created app icons.</p><p>We can use a little bit of imagination and tweak given icons on Sketch to give it a look of a travel or flight application.</p><img src="https://johnendres.com/images/aerogami-tutorial/part4/app_icon.gif" alt="Making of App Icon" width="300"/><p>The resulting icon looks like this.</p><img src="https://johnendres.com/images/aerogami-tutorial/part4/app_icon.png" alt="App Icon" width="300"/><p>We can use <a href="https://makeappicon.com">makeappicon.com</a> to generate all the necessary sizes of the icon so it could be used for different screen sizes as well as on AppStore.</p><h1>What's next?</h1><p>We saw how it's possible to create a clean design of an application without having much knowledge or spending too much time. Especially for small side projects, it's important to concentrate on main functionality and simply use best practices and examples when creating UIs.</p><p>In the next part of the series we'll shift our attention back to the development of our application. We'll see the approach for creating new screens and keeping the view and its logic cleanly separated.</p>]]></content:encoded></item></channel></rss>